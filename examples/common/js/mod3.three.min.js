/**
*
* MOD3  Plugin for Three.js
*
*
**/
!function(e,t){"use strict";var r,n,s=e.ModConstant,i=(s.X,s.Y,s.Z,e.xyz),u=e.XYZi,o=e.VecArray;r=e.VertexThree=e.Class(e.VertexProxy,{constructor:function(e,t){var r=this;r.$super("constructor",e,t),r.name="VertexThree"},setVertex:function(e){var t=this;return t.vertex=e,t.original=new o([e.x,e.y,e.z]),t},getXYZ:function(){var e=this.vertex,t=new o(3);return t[0]=e.x,t[1]=e.y,t[2]=e.z,t},getX:function(){return this.vertex.x},getY:function(){return this.vertex.y},getZ:function(){return this.vertex.z},getValue:function(e){return this.vertex[i[u[e]]]||0},setXYZ:function(e){var t=this.vertex;return t.x=e[0],t.y=e[1],t.z=e[2],this},setX:function(e){return this.vertex.x=e,this},setY:function(e){return this.vertex.y=e,this},setZ:function(e){return this.vertex.z=e,this},setValue:function(e,t){return this.vertex[i[u[e]]]=t,this},reset:function(){var e=this,t=e.vertex,r=e.original;return t.x=r[0],t.y=r[1],t.z=r[2],e},collapse:function(){var e=this,t=e.vertex,r=e.original;return r[0]=t.x,r[1]=t.y,r[2]=t.z,e}}),n=e.MeshThree=e.Class(e.MeshProxy,{constructor:function(e){var t=this;t.$super("constructor",e),t.name="MeshThree"},init:function(e){var t=this;t.$super("init",e);var n,s,e=t.mesh,i=e.geometry.vertices,u=i.length;for(t.faces=null,t.vertices=n=new Array(u),s=0;u>s;s++)n[s]=new r(i[s],t);return t},update:function(){var e=this,t=e.mesh.geometry;return t.verticesNeedUpdate=!0,t.elementsNeedUpdate=!0,t.uvsNeedUpdate=!0,t.normalsNeedUpdate=!0,t.colorsNeedUpdate=!0,t.lineDistancesNeedUpdate=!0,t.groupsNeedUpdate=!0,t.buffersNeedUpdate=!0,t.dynamic=!0,e},updateMeshPosition:function(e){var t=this,r=t.mesh.position,n=e.xyz;return r.x+=n[0],r.y+=n[1],r.z+=n[2],t}}),e.LibraryThree={id:"Three",Mesh:n,Vertex:r}}(MOD3);