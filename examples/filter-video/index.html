<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    
    <title>Video Processing with Filter.js</title>
    
    <link rel="stylesheet" type="text/css" href="../common/css/common.min.css" />
    <link rel="stylesheet" type="text/css" href="../common/css/areaselect.min.css" />
    <style type="text/css">
        body {
            position:relative;
            background-color: #121212;
            font-family: Helvetica, sans-serif;
            font-size:12px;
            color:#aaa;
            margin: 0px;
            padding: 0px;
            height:100%;
            min-height:900px; 
            overflow:scroll;
            border: none;
        }
        .panel {
            cursor:arrow;
            margin-left:20px;
            padding-left:10px;
            border-left:2px solid #aaa;
        }
        strong {
            font-size:14px;
        }
        #statsContainer {
            margin-bottom:20px;
        }
        .button {
            -moz-box-shadow:inset 0px 1px 0px 0px #f5978e;
            -webkit-box-shadow:inset 0px 1px 0px 0px #f5978e;
            box-shadow:inset 0px 1px 0px 0px #f5978e;
            background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #f24537), color-stop(1, #c62d1f) );
            background:-moz-linear-gradient( center top, #f24537 5%, #c62d1f 100% );
            filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#f24537', endColorstr='#c62d1f');
            background-color:#f24537;
            -webkit-border-top-left-radius:20px;
            -moz-border-radius-topleft:20px;
            border-top-left-radius:20px;
            -webkit-border-top-right-radius:20px;
            -moz-border-radius-topright:20px;
            border-top-right-radius:20px;
            -webkit-border-bottom-right-radius:20px;
            -moz-border-radius-bottomright:20px;
            border-bottom-right-radius:20px;
            -webkit-border-bottom-left-radius:20px;
            -moz-border-radius-bottomleft:20px;
            border-bottom-left-radius:20px;
            text-indent:0;
            border:1px solid #d02718;
            display:inline-block;
            color:#ffffff;
            font-family:Arial;
            font-size:15px;
            font-weight:bold;
            font-style:normal;
            height:50px;
            line-height:50px;
            width:2000px;
            text-decoration:none;
            text-align:center;
            text-shadow:1px 1px 0px #810e05;
        }
        .button:hover {
            background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #c62d1f), color-stop(1, #f24537) );
            background:-moz-linear-gradient( center top, #c62d1f 5%, #f24537 100% );
            filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#c62d1f', endColorstr='#f24537');
            background-color:#c62d1f;
        }.button:active {
            position:relative;
            top:1px;
        }
        .button {
            font-size:12px;
            width:100px;
            height:40px;
            line-height:40px;
            cursor:pointer;
            position:relative;
        }
        .img-area-select {
            border: 1px dashed #79b900;
            background: rgba(128, 128, 128, 0.4);
        }
        #forkongithub a{background:#c83022;color:#fff;}
        select, input[type="number"] {
            font-size: 1.8em !important;
            padding: 0.4em !important;
            color: black !important;
        }
    </style>
    <script src="../common/js/require.js"></script>
    <script src="../common/js/require-config.js"></script>
</head>
<body class="responsive-864-container">
    <span id="forkongithub"><a href="https://github.com/foo123/FILTER.js">Fork me on GitHub</a></span>
    
    <header id="header">
        <h1>Video Processing with Filter.js v.<span id="lib-version">0</span></h1><br /><br />
    </header>
    
    <div class="fluid col-1-1 text-left" style="margin-bottom: 10px; padding-left: 20px;"><a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=DP8WED9XW9TAE" class="donate">donate</a> or <a href="http://nikos-web-development.netai.net/#contact_tab" class="donate">hire me for a job</a></div>
    
    <div id="statsContainer"></div>
    
    <div class="fluid col-1-1">
    
        <div id="container" class="fluid col-2-5 panel">
            <strong>Original Video <a href="http://www.youtube.com/watch?v=alQ7KCaGBec" target="_blnak">on YouTube</a></strong><br /><br />
            <!-- autoplay -->
            <video id="video" loop="true" controls="true">
                <!--<source src="../common/assets/minions.mp4" type="video/mp4">
                <source src="../common/assets/minions.ogv" type="video/ogv">-->
                <source src="../common/assets/Waddys_Takeoff-The_Aftermath.mp4" type="video/mp4">
                <source src="../common/assets/Waddys_Takeoff-The_Aftermath.webm" type="video/webm">
                Video is not supported
            </video>
        </div>
        
        <div id="filters"  class="fluid col-2-5 panel">
            <strong>Post-Processed Video (downsampled)</strong><br /><br />
        </div>
    
    </div>
    
    <br /><br />
    
    <div class="fluid col-1-1" style="margin-bottom:100px;">
    
        <div class="panel">
            <strong>You can select part of video to apply filters to (use your mouse on the processed video on the right)</strong>&nbsp;&nbsp;
            <input id="select" type="button" class="button" value="Select" />
            <input id="deselect" type="button" class="button" value="DeSelect" />
        </div>
        
        <div class="panel">
            <strong>Apply Post-Process Filter to Video :</strong><br /><br />
            <select id="filterSelect">
                <option value='#'>None</option>
                <optgroup label="Color Table Filters">
                    <option value='#'>RED Channel</option>
                    <option value='#'>GREEN Channel</option>
                    <option value='#'>BLUE Channel</option>
                    <option value='#'>Solarize</option>
                    <option value='#'>Solarize2</option>
                    <option value='#'>Posterize</option>
                    <option value='#'>Invert</option>
                </optgroup>
                <optgroup label="Color Matrix Filters">
                    <option value='#'>RED Channel</option>
                    <option value='#'>GREEN Channel</option>
                    <option value='#'>BLUE Channel</option>
                    <option value='#'>Colorize</option>
                    <option value='#'>Grayscale</option>
                    <option value='#'>Grayscale and Contrast</option>
                </optgroup>
                <optgroup label="Color Map Filters and Color Space Transformations">
                    <option value='#'>YCbCr Color Space (Color Matrix)</option>
                    <option value='#'>HSV Color Space (Color Map)</option>
                    <option value='#'>CMY Color Space (Color Map)</option>
                    <option value='#'>Hue only as grayscale Image (Color Map)</option>
                </optgroup>
                <optgroup label="Convolution Matrix Filters">
                    <option value='#'>Emboss</option>
                    <option value='#'>Fast Gauss Blur 3x3</option>
                    <option value='#'>Fast Gauss Blur 7x7</option>
                    <option value='#'>Fast Gauss Blur 15x15</option>
                    <option value='#'>Fast Gauss Blur 51x51</option>
                    <option value='#'>Grayscale, Sobel Edges 3x3</option>
                    <option value='#'>Grayscale, Sobel Edges 3x3, Binary Threshold</option>
                    <option value='#'>Grayscale, Laplace Edges 5x5</option>
                    <option value='#'>Grayscale, Laplace Edges 11x11</option>
                    <option value='#'>Grayscale, Laplace Edges 5x5, Binary Threshold</option>
                    <option value='#'>Grayscale, Laplace Edges 11x11, Binary Threshold</option>
                    <option value='#'>Gray, Gauss, Laplace 5x5, Threshold</option>
                </optgroup>
                <optgroup label="Statistical/Morphological Filters">
                    <option value='#'>Minimum 3x3</option>
                    <option value='#'>Maximum 3x3</option>
                    <!--<option value='#'>Median 3x3</option>-->
                    <option value='#'>Morphological Dilate</option>
                </optgroup>
                <optgroup label="Displace/Affine/Geometric Filters">
                    <option value='#'>TwirlMap</option>
                    <option value='#'>SphereMap</option>
                    <!--<option value='#'>RippleMap</option>-->
                    <option value='#'>DisplaceMap with Radial Gradient</option>
                    <option value='#'>DisplaceMap with Perlin Noise</option>
                </optgroup>
                <optgroup label="Blend Filters">
                    <option value='#'>Blend</option>
                </optgroup>
                <optgroup label="Plugins and Composites">
                    <option value='#'>Noise</option>
                    <option value='#'>Equalize Histogram</option>
                    <option value='#'>Alpha Mask (ChannelCopy)</option>
                    <option value='#'>Bokeh (Depth-of-Field)</option>
                    <option value='#'>Pixelate 2%</option>
                    <option value='#'>Pixelate 3%</option>
                    <option value='#'>Pixelate 5%</option>
                    <option value='#'>Pixelate 10%</option>
                    <option value='#'>Triangular Pixelate 2%</option>
                    <option value='#'>Triangular Pixelate 3%</option>
                    <option value='#'>Triangular Pixelate 5%</option>
                    <option value='#'>Triangular Pixelate 10%</option>
                    <!--<option value='#'>Hexagonal Pixelate 2%</option>
                    <option value='#'>Hexagonal Pixelate 3%</option>
                    <option value='#'>Hexagonal Pixelate 5%</option>
                    <option value='#'>Hexagonal Pixelate 10%</option>-->
                    <option value='#'>Halftoned/Dithered</option>
                    <option value='#'>Extract range of Hues, Open Morphological</option>
                    <option value='#'>Quantize Hue and Extract Connected Components</option>
                    <option value='#'>Canny Edges Extractor</option>
                </optgroup>
            </select>
            &nbsp;
            <select id="flipSelect">
                <option value='0'>No Flip</option>
                <option value='1'>Flip Horizontal</option>
                <option value='2'>Flip Vertical</option>
                <option value='3'>Flip Horizontal using Filter</option>
                <option value='4'>Flip Vertical using Filter</option>
            </select>
            &nbsp;
            <select id="blendSelect">
                <option value='Normal'>Normal</option>
                <option value='Lighten'>Lighten</option>
                <option value='Darken'>Darken</option>
                <option value='Multiply'>Multiply</option>
                <option value='Average'>Average</option>
                <option value='Add'>Add</option>
                <option value='Subtract'>Subtract</option>
                <option value='Difference'>Difference</option>
                <option value='Negation'>Negation</option>
                <option value='Screen'>Screen</option>
                <option value='Exclusion'>Exclusion</option>
                <option value='Overlay'>Overlay</option>
                <option value='SoftLight'>SoftLight</option>
                <option value='HardLight'>HardLight</option>
                <option value='ColorDodge'>ColorDodge</option>
                <option value='ColorBurn'>ColorBurn</option>
                <option value='LinearLight'>LinearLight</option>
                <option value='Reflect'>Reflect</option>
                <option value='Glow'>Glow</option>
                <option value='Phoenix'>Phoenix</option>
                <option value='VividLight'>VividLight</option>
                <option value='PinLight'>PinLight</option>
                <option value='HardMix'>HardMix</option>
                <option value='LinearDodge'>LinearDodge (same as Add)</option>
                <option value='LinearBurn'>LinearBurn (same as Subtract)</option>
            </select>
            &nbsp;
            <input id="blendAlpha" type="number" value="1.0" step="0.1" style="width:60px" />
        </div>
    
    </div>
    
    <script>//<![CDATA[
    "use strict";
   /**
     * Provides requestAnimationFrame in a cross browser way.
     * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     */

    if ( !window.requestAnimationFrame ) {

        window.requestAnimationFrame = ( function() {

            return window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {

                window.setTimeout( callback, 1000 / 60 );

            };

        } )();

    }
    
    // utils
    function addEvent(el, ev, handler) { el.addEventListener(ev, handler, false); }
    function getEl(id) { return document.getElementById(id); }
    function add(el, child) { el.appendChild(child); }
    function addAll(el, childs) { var l=childs.length, i=0; while (i<l) { el.appendChild(childs[i]); i++; } }
    
    require.config({
        paths: {
            FilterBundle: "filter.bundle"
        },
        bundles: {
            FilterBundle: ["Classy", "Asynchronous", "FILTER", "FILTER_IO", "FILTER_CODECS", "FILTER_FILTERS", "FILTER_PLUGINS"]
        }
    });
    require(['Classy', 'Asynchronous', 'FILTER', 'FILTER_IO', 'FILTER_CODECS', 'FILTER_FILTERS', 'FILTER_PLUGINS', 'AreaSelect', 'Stats'/*, 'domReady!'*/], 
        function( _1, _2, _3, _4, _5, _6, $F, AreaSelect, Stats ) {
        document.getElementById('lib-version').innerHTML = $F.VERSION;
        var 
            icon,
            filterSelect = getEl('filterSelect'), 
            flipSelect = getEl('flipSelect'), 
            blendSelect = getEl('blendSelect'), 
            blendAlpha = getEl('blendAlpha'), 
            video = getEl('video'), 
            container = getEl('container'), 
            filters = getEl('filters'),
            selectBt = getEl('select'),
            deselectBt = getEl('deselect'),
            
            // images
            displacemap = $F.Image().restorable(false).fill("rgb(128,128,128)", 0, 0, 220, 220),
            perlinNoise = null,
            alphamask = $F.Image().restorable(false).fill("rgb(0,0,0)", 0, 0, 200, 200),
            postVideo = $F.Image().restorable(false),
            //postVideo = $F.ScaledImage(0.8, 0.8).restorable(false),
            //upscaleVideo = $F.ScaledImage(2, 2).restorable(false),
            
             // filters
            flipX = $F.AffineMatrixFilter().flipX(),
            flipY = $F.AffineMatrixFilter().flipY(),
            binary = $F.ColorTableFilter().threshold(0.7),
            solarize = $F.ColorTableFilter().solarize(0.6),
            solarize2 = $F.ColorTableFilter().solarize2(0.4),
            posterize = $F.ColorTableFilter().posterize(8),
            invert = $F.ColorTableFilter().invert(),
            //invert = $F.ColorMatrixFilter().invert(),
            gray = $F.ColorMatrixFilter().grayscale(),
            grc = $F.ColorMatrixFilter().grayscale().contrast(1),
            blur3 = $F.ConvolutionMatrixFilter().fastGauss(2, 3),
            blur7 = $F.ConvolutionMatrixFilter().fastGauss(2, 7),
            blur15 = $F.ConvolutionMatrixFilter().fastGauss(2, 15),
            blur51 = $F.ConvolutionMatrixFilter().fastGauss(2, 51),
            sobel = $F.ConvolutionMatrixFilter().sobel(3),
            laplace5 = $F.ConvolutionMatrixFilter().laplace(5),
            laplace11 = $F.ConvolutionMatrixFilter().laplace(11),
            grs = $F.CompositeFilter([gray, sobel]),
            grsb = $F.CompositeFilter([gray, sobel, binary]),
            grl5 = $F.CompositeFilter([gray, laplace5]),
            grl11 = $F.CompositeFilter([gray, laplace11]),
            grlb5 = $F.CompositeFilter([gray, laplace5, binary]),
            grlb11 = $F.CompositeFilter([gray, laplace11, binary]),
            grglb5 = $F.CompositeFilter([gray, blur3, laplace5, binary]),
            emboss = $F.ConvolutionMatrixFilter().emboss(),
            redCGray = $F.ColorMatrixFilter().redChannel(true),
            redC = $F.ColorMatrixFilter().redChannel(),
            greenC = $F.ColorMatrixFilter().greenChannel(),
            blueC = $F.ColorMatrixFilter().blueChannel(),
            redCT = $F.ColorTableFilter().redChannel(),
            greenCT = $F.ColorTableFilter().greenChannel(),
            blueCT = $F.ColorTableFilter().blueChannel(),
            clr = $F.ColorMatrixFilter().colorize(0xfdc171),
            equ = $F.HistogramEqualizeFilter($F.MODE.INTENSITY),
            minimum = $F.StatisticalFilter().minimum(3),
            maximum = $F.StatisticalFilter().maximum(3),
            // median is slow ..
            //median = $F.StatisticalFilter().median(3),
            mdilate = $F.MorphologicalFilter().dilate([
                0, 0, 0, 0, 0, 0, 1,
                0, 0, 0, 0, 0, 1, 0,
                0, 0, 0, 0, 1, 0, 0,
                0, 0, 0, 1, 0, 0, 0,
                0, 0, 1, 0, 0, 0, 0,
                0, 1, 0, 0, 0, 0, 0,
                1, 0, 0, 0, 0, 0, 0
            ]),
            open = $F.MorphologicalFilter().opening(3),
            //connected_components = $F.ConnectedComponentsFilter(4, 0.1),
            //quantize = $F.ColorTableFilter().quantize(128),
            //quantized_connected_components = $F.CompositeFilter([gray, /*laplace5,*/ /*quantize,*/ connected_components, $F.ThresholdFilter([100, 140], [0, 0xffffff, 0], 1)]),
            quantized_connected_components = $F.ConnectedComponentsFilter(4, 0.3, $F.MODE.HUE, 100),
            noise = $F.NoiseFilter(10, 70),
            displaceFilter = $F.DisplacementMapFilter(displacemap),
            twirlFilter = $F.GeometricMapFilter().twirl(Math.PI/2, 150, 0.5, 0.5),
            sphereFilter = $F.GeometricMapFilter().sphere(150, 0.5, 0.5),
            //rippleFilter = $F.GeometricMapFilter().ripple(10, 16, 10, 0, 0.5, 0.5),
            pixelate2 = $F.PixelateFilter(2),
            pixelate3 = $F.PixelateFilter(3),
            pixelate5 = $F.PixelateFilter(5),
            pixelate10 = $F.PixelateFilter(10),
            trianglepixelate2 = $F.TriangularPixelateFilter(2),
            trianglepixelate3 = $F.TriangularPixelateFilter(3),
            trianglepixelate5 = $F.TriangularPixelateFilter(5),
            trianglepixelate10 = $F.TriangularPixelateFilter(10),
            //hexapixelate2 = $F.HexagonalPixelateFilter(2),
            //hexapixelate3 = $F.HexagonalPixelateFilter(3),
            //hexapixelate5 = $F.HexagonalPixelateFilter(5),
            //hexapixelate10 = $F.HexagonalPixelateFilter(10),
            halftoned = $F.CompositeFilter([
                gray,
                $F.HalftoneFilter(1).threshold(0.4).grayscale(true)
            ]),
            alphaMask = $F.ChannelCopyFilter($F.CHANNEL.BLUE, $F.CHANNEL.ALPHA, 0.5, 0.5, 0).setMode($F.MODE.COLOR).setInput("source",alphamask),
            blend = $F.BlendFilter(["normal", 1, 1, 1/*,
                                    "screen", 50, 40, 0.7*/]),
            //swapChannel = new $F.ColorMatrixFilter().swapChannels($F.CHANNEL.BLUE, $F.CHANNEL.ALPHA),
            ycbcr = $F.ColorMatrixFilter().RGB2YCbCr(),
            //ycbcr = $F.YCbCrConverterFilter(),
            hsv = $F.ColorMapFilter().RGB2HSV(),
            cmyk = $F.ColorMapFilter().RGB2CMYK(),
            //hueOnly = $F.CompositeFilter([hsv, redCGray]),
            hueOnly = $F.ColorMapFilter().hue(),
            hueE = $F.ColorMapFilter().setMode($F.MODE.HUE).extract(10, 150),
            hueExtractor = $F.CompositeFilter([hueE, open]),
            bokeh = $F.BokehFilter(0.5, 0.5, 100, 10),
            canny = $F.CompositeFilter([gray, $F.CannyEdgesFilter(1.5, 5.5)]),
            shift = $F.AffineMatrixFilter().setMode($F.MODE.WRAP).shift(3, 0),
            //seamless = $F.SeamlessTileFilter(),
            //seamlessPerlin = $F.CompositeFilter([$F.PerlinNoiseFilter(100,80), $F.SeamlessTileFilter()]),
            //seamlessPerlin = $F.PerlinNoiseFilter(100,80).simplex().octaves(1).seamless(true),
            perlinDisplaceFilter = $F.DisplacementMapFilter(),
            //resample_and_process = $F.CompositeFilter([$F.ResampleFilter(0.7, 0.7), null, $F.ResampleFilter(1/0.7, 1/0.7)]),
            
            // filter selection list
            videoFilters = [
                null,
                redCT,
                greenCT,
                blueCT,
                solarize,
                solarize2,
                posterize,
                invert,
                redC,
                greenC,
                blueC,
                clr,
                gray,
                grc,
                ycbcr,
                hsv,
                cmyk,
                hueOnly,
                emboss,
                blur3,
                blur7,
                blur15,
                blur51,
                grs,
                grsb,
                grl5,
                grl11,
                grlb5,
                grlb11,
                grglb5,
                minimum,
                maximum,
                //median,
                mdilate,
                twirlFilter,
                sphereFilter,
                //rippleFilter,
                displaceFilter,
                perlinDisplaceFilter,
                blend,
                noise,
                equ,
                alphaMask,
                bokeh,
                pixelate2,
                pixelate3,
                pixelate5,
                pixelate10,
                trianglepixelate2,
                trianglepixelate3,
                trianglepixelate5,
                trianglepixelate10,
                /*hexapixelate2,
                hexapixelate3,
                hexapixelate5,
                hexapixelate10,*/
                halftoned,
                hueExtractor,
                quantized_connected_components,
                canny
            ],
            currentOrientation = 0, currentBlendMode = "normal", currentBlendAlpha = 1.0,
            currentFilterIndex = 0,  currentFilter = videoFilters[currentFilterIndex],
            renderInterval = 60,  rnd = Math.random, Max = Math.max, dx, dy, dx2, dy2, dtheta, dr, vw, vh,
            currentSelection = null, areaSelect, doSelect = false, doDeselect = false,
            cX1 = 0, cX2 = 0, cY1 = 0, cY2 = 0, stats
        ;
        
        function init( )
        {
            blend.setInput(1, icon = $F.IO.HTMLImageLoader.load($F.Browser.isChrome
            ? "../common/assets/chrome.png"
            : ($F.Browser.isOpera
            ? "../common/assets/opera.png"
            : ($F.Browser.isIE
            ? "../common/assets/ie.png"
            : "../common/assets/firefox.png"))).restorable(false));
            //blend.setInput(2, $F.IO.HTMLImageLoader.load("../common/assets/chrome.png").restorable(false));
            blendSelect.style.display = "none";
            blendAlpha.style.display = "none";
            selectBt.style.display = "inline";
            deselectBt.style.display = "none";
            
            var grd;
            // create a displace map image
            // create radial gradient
            grd = displacemap.octx.createRadialGradient(displacemap.width/2, displacemap.height/2, 0, displacemap.width/2, displacemap.height/2, displacemap.width/2);
            grd.addColorStop(1, "#808080"); // neutral
            grd.addColorStop(0, "#ffffff"); // white
            displacemap.octx.fillStyle = grd;
            displacemap.octx.beginPath();
            displacemap.octx.arc(displacemap.width/2, displacemap.height/2, displacemap.width/2, 0, Math.PI*2, true);
            displacemap.octx.fill();
            displacemap.store();
            displaceFilter.startX=0; displaceFilter.startY=0;
            displaceFilter.scaleX=120; displaceFilter.scaleY=120; 
            displaceFilter.componentX=$F.CHANNEL.RED; displaceFilter.componentY=$F.CHANNEL.GREEN;
            
            perlinDisplaceFilter.startX=0; perlinDisplaceFilter.startY=0;
            perlinDisplaceFilter.scaleX=60; perlinDisplaceFilter.scaleY=60; 
            perlinDisplaceFilter.componentX=$F.CHANNEL.RED; perlinDisplaceFilter.componentY=$F.CHANNEL.GREEN;
            
            // create alpha mask image
            // create radial gradient
            grd = alphamask.octx.createRadialGradient(alphamask.width/2, alphamask.height/2, 0, alphamask.width/2, alphamask.height/2, alphamask.width/2);
            grd.addColorStop(1, "#000000"); // black
            grd.addColorStop(0, "#ffffff"); // white
            alphamask.octx.fillStyle = grd;
            alphamask.octx.beginPath();
            alphamask.octx.arc(alphamask.width/2, alphamask.height/2, alphamask.width/2, 0, Math.PI*2, true);
            alphamask.octx.fill();
            alphamask.store();
            
            dx = Max(10*rnd(), 5); dy = Max(10*rnd(), 5); 
            dtheta = Math.PI*Max(2*rnd(), 1)/32;  
            dr = Max(2*rnd()+1, 1);
            
            add(filters, postVideo.domElement);
            areaSelect = new AreaSelect( postVideo.domElement );
            
            stats = new Stats();
            stats.setMode( 1 );
            add(statsContainer, stats.domElement );
            
            // change the video filter applied
            addEvent(filterSelect, "change", function(){
                currentFilterIndex = filterSelect.selectedIndex || 0;
                // preview the filter while hovering the option
                currentFilter = videoFilters[ currentFilterIndex ] || null;
                if (blend === currentFilter)
                {
                    blendSelect.style.display = "inline-block";
                    blendAlpha.style.display = "inline-block";
                }
                else
                {
                    blendSelect.style.display = "none";
                    blendAlpha.style.display = "none";
                }
            });
            
            // change the orientation applied
            addEvent(flipSelect, "change", function(){
                currentOrientation = flipSelect.selectedIndex || 0;
            });
            
            // change the blend mode
            addEvent(blendSelect, "change", function(){
                currentBlendMode = blendSelect.options[blendSelect.selectedIndex || 0].value.toLowerCase();
            });
            
            // change the blend alpha
            addEvent(blendAlpha, "change", function(){
                currentBlendAlpha = +blendAlpha.value;
                if ( currentBlendAlpha < 0 )
                {
                    currentBlendAlpha = 0;
                    blendAlpha.value = currentBlendAlpha;
                }
                if ( currentBlendAlpha > 1 )
                {
                    currentBlendAlpha = 1;
                    blendAlpha.value = currentBlendAlpha;
                }
            });
            
            addEvent(selectBt, 'click', function(){
                var sel = areaSelect.getSelection();
                if ( sel )
                {
                    var w = postVideo.width, h = postVideo.height;
                    currentSelection = [ Math.min(sel.x1/w, 1), Math.min(sel.y1/h, 1), Math.min(sel.x2/w, 1), Math.min(sel.y2/h, 1) ];
                    areaSelect.hide();
                    doSelect = true;
                    
                    cX1 = sel.x1;
                    cY1 = sel.y1;
                    cX2 = sel.x2;
                    cY2 = sel.y2;

                    setTimeout(function(){
                        selectBt.style.display = 'none';
                        deselectBt.style.display = 'inline';
                    }, 10);
                }
                else
                {
                    currentSelection = null;
                }
                return false;
            });
            
            addEvent(deselectBt, 'click', function(){
                currentSelection = null;
                areaSelect.hide();
                doDeselect = true;
                
                cX1 = 0;
                cY1 = 0;
                cX2 = postVideo.width;
                cY2 = postVideo.height;

                setTimeout(function(){
                    selectBt.style.display = 'inline';
                    deselectBt.style.display = 'none';
                }, 10);
                return false;
            });
            
            // start process when the video is playing
            addEvent( video, "play", processVideo );
        }
        
        function processVideo(event)
        {
            if (video.paused || video.ended)  return;

            // Render every fixed interval
            requestAnimationFrame( processVideo );
            //setTimeout( processVideo, renderInterval );
            
            var vw, vh, brad;
            
            stats.begin( );
            
            postVideo.image( video );
            
            vw = postVideo.width; vh = postVideo.height;
            
            if ( 0 === cX2 )
            {
                cX1 = 0;
                cY1 = 0;
                cX2 = vw;
                cY2 = vh;
            }
                
            // down-scale
            //downscaleVideo.setImage(video);
            if (doSelect && currentSelection)
            {
                postVideo.select( currentSelection[0], currentSelection[1], currentSelection[2], currentSelection[3] );
                blend.matrix[1]/*startX*/ = cX1+1; 
                blend.matrix[2]/*startY*/ = cY1+1;
                doSelect = false;
            }
            else if (doDeselect)
            {
                postVideo.deselect( );
                blend.matrix[1]/*startX*/ = 1; 
                blend.matrix[2]/*startY*/ = 1;
                doDeselect = false;
            }
            
            if (1==currentOrientation)   postVideo.flipHorizontal( );
            else if (2==currentOrientation)  postVideo.flipVertical( );
            else if (3==currentOrientation)   flipX.apply( postVideo );
            else if (4==currentOrientation)  flipY.apply( postVideo );
            
            if (displaceFilter===currentFilter)
            {
                // animate the displace filter
                displaceFilter.startX += dx/vw; 
                displaceFilter.startY += dy/vh;
                if (displaceFilter.startX<-0.5 || displaceFilter.startX>0.5) dx = -dx;
                if (displaceFilter.startY<-0.5 || displaceFilter.startY>0.5) dy = -dy;
                //postVideo.image( /*alphamask*/displacemap );
            }
            else if (perlinDisplaceFilter===currentFilter)
            {
                if ( null === perlinNoise )
                {
                    perlinDisplaceFilter.setInput( "map", perlinNoise = $F.Image.PerlinNoise( vw, vh, 0, true/* seamless */, true/* grayscale */, 100, 80 ) );
                }
                else
                {
                    // animate the perlinNoise image
                    shift.apply( perlinNoise );
                }
            }
            else if (twirlFilter===currentFilter)
            {
                // animate the twirl filter
                twirlFilter.angle += dtheta;
                if (twirlFilter.angle < -Math.PI/2 || twirlFilter.angle > Math.PI/2) dtheta=-dtheta;
                twirlFilter.centerX += dx/vw; 
                twirlFilter.centerY += dy/vh;
                if (twirlFilter.centerX<0 || twirlFilter.centerX>1) dx = -dx;
                if (twirlFilter.centerY<0 || twirlFilter.centerY>1) dy = -dy;
            }
            else if (sphereFilter===currentFilter)
            {
                // animate the sphere filter
                sphereFilter.centerX += dx/vw; 
                sphereFilter.centerY += dy/vh;
                if (sphereFilter.centerX<0 || sphereFilter.centerX>1) dx = -dx;
                if (sphereFilter.centerY<0 || sphereFilter.centerY>1) dy = -dy;
            }
            /*else if (rippleFilter===currentFilter)
            {
                // animate the ripple filter
                brad = Max(vw, vh);
                rippleFilter.radius += dr; 
                rippleFilter.phase += dtheta; 
                rippleFilter.wavelength = 25;
                if (rippleFilter.phase < -Math.PI || rippleFilter.phase > Math.PI) dtheta=-dtheta;
                if (rippleFilter.radius<0 || rippleFilter.radius>brad) dr = -dr;
            }*/
            else if (alphaMask===currentFilter)
            {
                // animate the mask filter
                alphaMask.centerX += dx/vw; 
                alphaMask.centerY += dy/vh;
                if (alphaMask.centerX<0 || alphaMask.centerX>1) dx = -dx;
                if (alphaMask.centerY<0 || alphaMask.centerY>1) dy = -dy;
            }
            else if (blend===currentFilter)
            {
                // animate the blend filter
                blend.matrix[0]/*mode*/ = currentBlendMode; 
                blend.matrix[1]/*startX*/ += dx; 
                blend.matrix[2]/*startY*/ += dy;
                blend.matrix[3]/*alpha*/ = currentBlendAlpha;
                if (blend.matrix[1]<=cX1 || blend.matrix[1]>=cX2) dx = -dx;
                if (blend.matrix[2]<=cY1 || blend.matrix[2]>=cY2) dy = -dy;
                //console.log(blend.input(1));
            }
            
            /*if ( currentFilter )
            {
                resample_and_process._stack[1] = currentFilter;
                resample_and_process.apply( postVideo );
            }*/
            if ( currentFilter ) currentFilter.apply( postVideo );
            
            // up-scale
            //upscaleVideo.setImage(downscaleVideo.canvasElement);
            
            stats.end( );
        }
        
        // play
        init( );
        
    });
    //]]></script>
</body>
</html>